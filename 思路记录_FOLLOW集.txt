关于为什么存储First集和Follow集的类明明域和方法除了名字完全相同，但是把它们分成两个类，主要是为了可读性。
以现阶段的水平来看，宁愿牺牲性能和代码包大小，也不要牺牲可读性

已有功能：
	目前能够获取任意单个非终结符的First集

FOLLOW集的具体构建
重复进行下列步骤，直到某次处理完成后FollowSets没有发生任何变化
	首先将$放入FOLLOW（S）中（S是开始符号，可以设定为第一个产生式的左部）
	依次处理每一个产生式（循环）
		取出产生式的左部LHS和右部RHS
		依次处理产生式的每个右部
			依次处理右部的每两个语法符号，第i个语法符号X和第i+1个语法符号Y（循环i++）
				如果第i个语法符号X是终结符，continue
				如果第i个语法符号X是非终结符，
					如果没有第i+1个语法符号，就将LHS的Follow集添加到第i个语法符号的Follow集中
					否则，获取第i+1个到最后一个语法符号这些语法符号组成的串的First集
						将这个First集加入到第i个语法符号的Follow集中
						如果First集中包含empty，则把左部的Follow集也加入到x的Follow集中
						如果First集中不包含empty，continue

Follow集在添加内容的时候会自动去除待添加内容里的“empty”

另一种思路：
	遍历每一个右部包含非终结符x的产生式
	如果x的下一个字符是终结符，添加进x的Follow集
	如果x的下一个字符是非终结符，把该字符的First集加入x的Follow集（不能加入空串）
	如果下一个字符的First集有空串并且该产生式的左部不是x，则把左部的Follow集加入x的Follow集
	如果x已经是产生式的末尾，则把左部的Follow集添加到x的Follow集里

思路特点：与之前写的那个构造First集的算法不同，不是从产生式的左部着手，而是从右部着手
	采用填空的形式，补全所有的Follow集